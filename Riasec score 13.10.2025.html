<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Comparateur RIASEC — Prediger (Objets/Personnes & Faits/Idées)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 18px; color:#222; }
    header { display:flex; align-items:center; gap:12px; margin-bottom:12px; flex-wrap:wrap; }
    h1 { font-size:1.2rem; margin:0; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .scales { display:flex; flex-direction:column; gap:12px; margin-top:12px; }
    .scale {
      border:1px solid #ddd; padding:10px; border-radius:8px; background:#fafafa;
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .scale h4 { margin:0 8px 0 0; font-size:0.95rem; }
    label { font-size:0.9rem; }
    input[type="text"], input[type="number"] {
      padding:6px 8px; border:1px solid #ccc; border-radius:6px; font-size:0.9rem;
    }
    .scores { display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .scores input { width:70px; }
    .invalid { border-color:#d93025; background:#ffecec; }
    .btn { padding:8px 12px; border-radius:6px; border:none; cursor:pointer; font-weight:600; }
    .btn-primary { background:#2b6cb0; color:white; }
    .btn-ghost { background:#fff; border:1px solid #ccc; color:#222; }
    .btn-danger { background:#d9534f; color:white; }
    #chart-wrap { max-width:920px; margin:18px auto; }
    #riasecChart { width:100% !important; height:520px !important; display:block; }
    #summary { text-align:left; margin-top:12px; font-weight:600; white-space:pre-wrap; }
    .small { font-weight:400; font-size:0.9rem; color:#444; margin-top:6px; }
    .note { font-size:0.9rem; color:#333; margin-top:8px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .prediger { font-size:0.9rem; color:#333; margin-top:8px;}
    @media (max-width:520px) {
      .scores input { width:56px; }
      input[type="text"], input[type="number"] { width:100%; }
      .scale { flex-direction:column; align-items:stretch; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Comparateur RIASEC — multi-échelles + Prediger</h1>
    <div class="controls">
      <button id="addScaleBtn" class="btn btn-primary">+ Ajouter une échelle</button>
      <button id="plotBtn" class="btn btn-primary">Afficher le graphique</button>
      <button id="resetBtn" class="btn btn-ghost">Réinitialiser</button>
    </div>
  </header>

  <main>
    <div class="small">Ajoute des échelles, renseigne nom, étendue et scores R,I,A,S,E,C. Coche un ou plusieurs éléments pour les afficher. Pour la lisibilité, éviter d'afficher trop de courbes simultanément.</div>

    <div id="scalesContainer" class="scales"></div>

    <div id="chart-wrap">
      <canvas id="riasecChart"></canvas>
      <div id="summary" aria-live="polite"></div>

      <ul class="note" id="footnote">
        <strong>La différentiation </strong>est calculée via la technique du Pr Vignaud et avec les étalonnages du RIASEC Flash 2 du Fabien Beltrame <a href="http://deporientation.free.fr/Ressources/Manuel_RIASECFlash2_V3.1.pdf" target="_blank">référence page 17</a>
      </ul>

      <div class="note" id="diff-interpretation">
        <strong>Interprétation de la différenciation</strong> : un indice de différenciation étalonné en classe IV indique un profil RIASEC moyennement différencié ; en classe I, II ou III le profil est faiblement différencié ; en classe V, VI ou VII le profil est fortement différencié.
      </div>

      <div class="prediger" id="prediger-note">
        Les <strong>dimensions de Prediger</strong> (calculées avec la méthode de <a href="https://www.researchgate.net/publication/232418263_Adherence_to_RIASEC_Structure_as_a_Key_Career_Decision_Construct" target="_blank">Tracey</a>) sont : <em>Objets vs Personnes</em> et <em>Faits vs Idées</em>.
      </div>
    </div>
  </main>

  <script>
    // =================================================================================
    // CONSTANTES ET VARIABLES GLOBALES
    // =================================================================================
    // Labels RIASEC dans l'ordre standard
    const LABELS = ['R','I','A','S','E','C'];
    // Compteur pour générer des IDs uniques pour chaque échelle
    let scaleIdCounter = 0;
    // Stockage de toutes les échelles créées
    // Structure: {id, name, max, values:[6], selected}
    let scales = [];

    // =================================================================================
    // PALETTE DE COULEURS POUR LES GRAPHES
    // =================================================================================
    // Palette de 8 couleurs distinctes pour différencier les échelles sur le graphique
    const BASE_COLORS = [
      'rgba(220,53,69,1)',    // Rouge
      'rgba(13,110,253,1)',   // Bleu
      'rgba(40,167,69,1)',    // Vert
      'rgba(255,193,7,1)',    // Jaune
      'rgba(102,16,242,1)',   // Violet
      'rgba(23,162,184,1)',   // Cyan
      'rgba(255,87,34,1)',    // Orange
      'rgba(0,123,255,1)'     // Bleu secondaire
    ];

    // =================================================================================
    // GESTION DES COULEURS POUR LES GRAPHES
    // =================================================================================
    /**
     * Génère une paire de couleurs (bordure + fond) pour une échelle donnée
     * @param {number} i - Index de l'échelle (0, 1, 2, etc.)
     * @returns {object} Objet avec border (opaque) et background (translucide)
     */
    function colorForIndex(i) {
      // Sélectionne une couleur de base en bouclant sur la palette
      const base = BASE_COLORS[i % BASE_COLORS.length];
      // Crée une version translucide pour le fond (remplace opacity 1 par 0.18)
      const bg = base.replace(/1\)$/, '0.18)');
      return { border: base, background: bg };
    }

    // =================================================================================
    // INITIALISATION DE L'APPLICATION
    // =================================================================================
    /**
     * Événement déclenché quand le DOM est complètement chargé
     * Crée automatiquement deux échelles d'exemple au démarrage
     */
    window.addEventListener('DOMContentLoaded', () => {
      // Ajoute une échelle d'autoévaluation (notation 1-5)
      addScale('Autoévaluation', 5, [0,0,0,0,0,0]);
      // Ajoute une échelle de test en ligne (notation 0-100)
      addScale('Test en ligne', 100, [0,0,0,0,0,0]);
    });

    // =================================================================================
    // GESTION DES ÉCHELLES RIASEC
    // =================================================================================
    /**
     * Crée une nouvelle échelle RIASEC avec ses contrôles HTML associés
     * @param {string} name - Nom de l'échelle (ex: "Autoévaluation", "Test professionnel")
     * @param {number} max - Valeur maximale possible (ex: 5 pour une échelle 1-5, 100 pour un test)
     * @param {number[]} values - Scores RIASEC [R, I, A, S, E, C]
     */
    function addScale(name='Échelle', max=5, values=[0,0,0,0,0,0]) {
      const id = ++scaleIdCounter;
      const s = { id, name, max, values: values.slice(), selected: false };
      scales.push(s);

      const container = document.getElementById('scalesContainer');
      const el = document.createElement('div');
      el.className = 'scale';
      el.id = `scale-${id}`;
      el.innerHTML = `
        <div style="display:flex;align-items:center;gap:8px;">
          <input type="checkbox" id="select-${id}" aria-label="Sélection ${id}">
        </div>
        <div style="flex:1;min-width:220px;">
          <div class="row">
            <h4>Échelle</h4>
            <input type="text" id="name-${id}" value="${escapeHtml(name)}" style="min-width:160px;">
            <label>Étendue max</label>
            <input type="number" id="max-${id}" value="${max}" min="1" step="any" style="width:85px;">
            <button class="btn btn-danger" id="del-${id}" title="Supprimer">Suppr</button>
          </div>
          <div class="scores" id="scores-${id}">
            ${LABELS.map((L,i)=>`<label>${L}: <input type="number" id="val-${id}-${L}" value="${values[i]}" step="any"></label>`).join('')}
          </div>
        </div>
      `;
      container.appendChild(el);

      document.getElementById(`del-${id}`).addEventListener('click', ()=> removeScale(id));
      document.getElementById(`select-${id}`).addEventListener('change', (e)=> toggleSelect(id, e.target.checked));
      document.getElementById(`name-${id}`).addEventListener('input', (e)=> updateScaleMeta(id,'name', e.target.value));
      document.getElementById(`max-${id}`).addEventListener('input', (e)=> updateScaleMeta(id,'max', parseFloat(e.target.value)));
      LABELS.forEach(L => {
        document.getElementById(`val-${id}-${L}`).addEventListener('input', (e)=> updateScaleValue(id, L, e.target.value));
      });
    }

    function removeScale(id) {
      scales = scales.filter(s=>s.id!==id);
      const el = document.getElementById(`scale-${id}`); if (el) el.remove();
      updateEmptyIfNeeded();
    }

    function updateScaleMeta(id, prop, val) {
      const s = scales.find(x=>x.id===id); if (!s) return;
      if (prop === 'max') s.max = (isNaN(val) || val <= 0) ? 1 : val;
      else s.name = String(val || '');
    }

    function updateScaleValue(id, label, raw) {
      const s = scales.find(x=>x.id===id); if (!s) return;
      const idx = LABELS.indexOf(label);
      const v = parseFloat(raw);
      s.values[idx] = raw === '' ? '' : (isNaN(v) ? '' : v);
      const input = document.getElementById(`val-${id}-${label}`);
      if (raw === '' || isNaN(v) || v < 0 || v > s.max) input.classList.add('invalid');
      else input.classList.remove('invalid');
    }

    function toggleSelect(id, checked) {
      const s = scales.find(x=>x.id===id); if (!s) return;
      s.selected = checked;
    }

    document.getElementById('addScaleBtn').addEventListener('click', ()=> {
      addScale('Nouvelle échelle', 5, [0,0,0,0,0,0]);
      const last = document.getElementById(`scale-${scaleIdCounter}`);
      if (last) last.scrollIntoView({ behavior:'smooth', block:'center' });
    });

    document.getElementById('resetBtn').addEventListener('click', ()=> {
      scales = []; scaleIdCounter = 0;
      document.getElementById('scalesContainer').innerHTML = '';
      document.getElementById('summary').innerText = '';
      if (window.myChart) { window.myChart.destroy(); window.myChart = null; }
      addScale('Autoévaluation', 5, [0,0,0,0,0,0]);
      addScale('Test en ligne', 100, [0,0,0,0,0,0]);
    });

    function validateScale(s) {
      for (let i=0;i<6;i++) {
        const raw = s.values[i];
        const v = parseFloat(raw);
        if (raw === '' || isNaN(v) || v < 0 || v > s.max) return false;
      }
      return true;
    }

    // =================================================================================
    // FONCTIONS DE CALCUL ET DE NORMALISATION
    // =================================================================================
    /**
     * Normalise une valeur pour l'affichage sur le graphique radar (échelle 0-5)
     * @param {number} value - Valeur brute à normaliser
     * @param {number} max - Valeur maximale possible pour cette échelle
     * @returns {number} Valeur normalisée entre 0 et 5
     */
    function normalizeForChart(value, max) {
      if (max <= 0) return 0;
      // Formule: (valeur / max) * 5, arrondi à 1 décimale
      return Math.round((value / max) * 5 * 10) / 10;
    }

    /**
     * Convertit une valeur en pourcentage (0-100%)
     * @param {number} value - Valeur à convertir
     * @param {number} max - Valeur maximale de référence
     * @returns {number} Pourcentage arrondi
     */
    function toPercent100(value, max) {
      if (max <= 0) return 0;
      return (value / max) * 100;
    }

    /**
     * Identifie les deux types RIASEC dominants dans un profil
     * @param {number[]} scores - Scores RIASEC normalisés [R, I, A, S, E, C]
     * @returns {string[]} Les deux types principaux triés par score décroissant
     */
    function getTopTwoTypes(scores) {
      // Associe chaque type à son score
      const paired = LABELS.map((lab,i)=>({ type:lab, score:scores[i] }));
      // Trie par score décroissant
      paired.sort((a,b)=> b.score - a.score);
      return [paired[0].type, paired[1].type];
    }

    // =================================================================================
    // ANALYSE DE LA CONSISTANCE ENTRE TYPES RIASEC
    // =================================================================================
    /**
     * Évalue la cohérence entre les deux types RIASEC dominants
     * Utilise la structure hexagonale RIASEC pour mesurer la proximité
     * @param {string} type1 - Premier type dominant (ex: "R", "I", "A", etc.)
     * @param {string} type2 - Deuxième type dominant
     * @returns {string} Niveau de consistance: "Forte", "Moyenne" ou "Faible"
     */
    function evaluateConsistance(type1, type2) {
      // Structure hexagonale RIASEC dans l'ordre
      const hex = ['R','I','A','S','E','C'];
      // Trouve les positions des deux types dans l'hexagone
      const i1 = hex.indexOf(type1), i2 = hex.indexOf(type2);
      // Calcule la distance la plus courte (min entre sens horaire et anti-horaire)
      const d = Math.min(Math.abs(i1-i2), 6 - Math.abs(i1-i2));
      // Interprétation selon la proximité:
      if (d === 1) return 'Forte';      // Types adjacents (R-I, I-A, etc.)
      if (d === 2) return 'Moyenne';    // Types espacés d'un intervalle
      return 'Faible';                  // Types opposés ou très éloignés
    }

    // =================================================================================
    // CALCUL DE L'INDICE DE DIFFÉRENTIATION RIASEC
    // =================================================================================
    /**
     * Calcule l'indice de différentiation selon la méthode de Pr Vignaud
     * Formule: D = (t1 - (t2 + t3)/2) + (t3 - (t4 + t5)/2)
     * où t1 à t5 sont les 5 premiers scores triés par ordre décroissant
     * @param {number[]} values - Scores RIASEC bruts [R, I, A, S, E, C]
     * @param {number} max - Valeur maximale possible pour cette échelle
     * @returns {number} Indice D arrondi à 2 décimales (échelle 0-24 max)
     */
    function computeDifferentiationIndex_on100(values, max) {
      // Convertit les scores selon l'étalonnage RIASEC (max 24, pas 100)
      const normalized = values.map(v => (parseFloat(v) / max) * 24);
      // Trie les scores normalisés par ordre décroissant
      const s = normalized.slice().sort((a,b)=> b - a);
      // Extrait les 5 premiers scores (avec valeur par défaut 0 si undefined)
      const t1 = s[0] || 0, t2 = s[1] || 0, t3 = s[2] || 0, t4 = s[3] || 0, t5 = s[4] || 0;
      // Applique la formule de différentiation
      const D = (t1 - (t2 + t3)/2) + (t3 - (t4 + t5)/2);
      return Math.round(D * 100) / 100;
    }

    // =================================================================================
    // CLASSIFICATION DE LA DIFFÉRENTIATION PAR SEXE
    // =================================================================================
    /**
     * Classe l'indice de différentiation selon les normes établies
     * Utilise des barèmes différents pour hommes et femmes selon RIASEC Flash 2
     * @param {number} D - Indice de différentiation calculé (échelle 0-24)
     * @returns {object} Objet avec les classes pour homme et femme
     */
    function classifyDifferentiation(D) {
      // Définition des classes avec intervalles spécifiques homme/femme (RIASEC Flash 2)
      const classes = [
        { name:'I', homme:[0,2], femme:[0,2] },
        { name:'II', homme:[3,4], femme:[3,4] },
        { name:'III', homme:[5,6], femme:[5,8] },
        { name:'IV', homme:[7,8], femme:[9,10] },
        { name:'V', homme:[9,12], femme:[11,13] },
        { name:'VI', homme:[13,15], femme:[14,16] },
        { name:'VII', homme:[16,24], femme:[17,24] }
      ];

      /**
       * Trouve la classe correspondant à un indice D pour un sexe donné
       * @param {number} D - Indice de différentiation
       * @param {string} sex - 'homme' ou 'femme'
       * @returns {string} Nom de la classe (I à VII)
       */
      const findClass = (D, sex) => {
        for (let c of classes) {
          const r = sex === 'homme' ? c.homme : c.femme;
          if (D >= r[0] && D <= r[1]) return c.name;
        }
        return 'VII'; // Classe maximale par défaut
      };
      return { homme: findClass(D,'homme'), femme: findClass(D,'femme') };
    }

    /**
     * Convertit une classe de différentiation en niveau interprétable
     * @param {string} clsName - Nom de la classe (I, II, III, etc.)
     * @returns {string} Niveau de différentiation: "Faible", "Moyenne" ou "Forte"
     */
    function differentiationLevelFromClass(clsName) {
      if (['I','II','III'].includes(clsName)) return 'Faible';
      if (clsName === 'IV') return 'Moyenne';
      return 'Forte';
    }

    // =================================================================================
    // CALCUL DES DIMENSIONS DE PREDIGER/TRACEY
    // =================================================================================
    /**
     * Calcule les dimensions de Prediger selon la méthode de Tracey
     * Ces dimensions orthogonales aux types RIASEC permettent une analyse complémentaire
     * @param {number[]} values - Scores RIASEC bruts [R, I, A, S, E, C]
     * @param {number} max - Valeur maximale possible pour cette échelle
     * @returns {object} Objet avec things_people et ideas_data
     *
     * Formules:
     * - Things/People = (2*R + I - A - 2*S - E + C)
     * - Ideas/Data = (1.73*I + 1.73*A - 1.73*E - 1.73*C)
     */
    function computePredigerOn100(values, max) {
      // Convertit les scores bruts en pourcentages
      const pct = values.map(v => toPercent100(parseFloat(v), max));

      // Mappe les valeurs selon l'ordre RIASEC standard
      const R = pct[0] || 0, I = pct[1] || 0, A = pct[2] || 0,
            S = pct[3] || 0, E = pct[4] || 0, C = pct[5] || 0;

      // Applique les formules de Prediger/Tracey
      const things_people = (2*R + I - A - 2*S - E + C);
      const ideas_data = (1.73*I + 1.73*A - 1.73*E - 1.73*C);

      // Retourne les valeurs arrondies à 2 décimales
      return {
        things_people: Math.round(things_people * 100) / 100,
        ideas_data: Math.round(ideas_data * 100) / 100
      };
    }

    // =================================================================================
    // VISUALISATION GRAPHIQUE AVEC CHART.JS
    // =================================================================================
    /**
     * Crée et affiche le graphique radar RIASEC avec plusieurs échelles
     * @param {number[][]} datasets - Tableau de datasets (chaque dataset = [R,I,A,S,E,C] normalisés)
     * @param {string[]} labelsForDatasets - Noms des échelles pour la légende
     */
    function renderChart(datasets, labelsForDatasets) {
      // Prépare les données pour Chart.js
      const data = {
        // Labels des axes (types RIASEC)
        labels: LABELS,
        // Chaque échelle devient un dataset avec ses propres couleurs
        datasets: datasets.map((d,i) => {
          const col = colorForIndex(i);
          return {
            label: labelsForDatasets[i],
            data: d,
            borderColor: col.border,
            backgroundColor: col.background,
            pointBackgroundColor: col.border,
            fill: true
          };
        })
      };

      // Configuration du graphique radar
      const config = {
        type: 'radar',
        data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            r: {
              min:0,
              max:5,
              ticks:{ stepSize:1 },
              pointLabels: { font: { size:12 } }
            }
          },
          plugins: {
            title: { display:true, text:'Profil RIASEC (normalisé 1–5)' },
            legend: { position:'top', labels: { usePointStyle:true } }
          }
        }
      };

      // Récupère le canvas et crée/détruit le graphique
      const ctx = document.getElementById('riasecChart');
      if (window.myChart) window.myChart.destroy(); // Évite les conflits
      window.myChart = new Chart(ctx, config);
    }

    // =================================================================================
    // GÉNÉRATION DU RAPPORT D'ANALYSE
    // =================================================================================
    /**
     * Génère un résumé détaillé de l'analyse RIASEC pour chaque échelle
     * @param {object[]} entries - Tableau d'objets contenant les résultats d'analyse
     * @returns {string} Rapport formaté avec tous les indicateurs
     */
    function buildSummary(entries) {
      return entries.map((e,i) => {
        // Convertit les classes en niveaux de différentiation lisibles
        const diffLevelH = differentiationLevelFromClass(e.class.homme);
        const diffLevelF = differentiationLevelFromClass(e.class.femme);

        // Interprète les dimensions de Prediger
        const things_label = e.pred.things_people > 0 ? 'Orientation Objets' :
                           (e.pred.things_people < 0 ? 'Orientation Personnes' : 'Neutre');
        const ideas_label = e.pred.ideas_data > 0 ? 'Orientation Idées' :
                          (e.pred.ideas_data < 0 ? 'Orientation Faits' : 'Neutre');

        // Formatage du résumé pour une échelle
        return `${i+1}. ${e.name}:\n` +
               `  Profil: ${e.top[0]}${e.top[1]} → Consistance ${e.consistance}\n` +
               `  Différentiation=${e.D} (sur base 24) • Classe H:${e.class.homme}/${diffLevelH} • Classe F:${e.class.femme}/${diffLevelF}\n` +
               `  Prediger: Objets/Personnes=${e.pred.things_people} (${things_label}); Faits/Idées=${e.pred.ideas_data} (${ideas_label})`;
      }).join('\n\n');
    }

    // =================================================================================
    // TRAITEMENT PRINCIPAL - ANALYSE ET VISUALISATION
    // =================================================================================
    /**
     * Gestionnaire d'événement pour le bouton "Afficher le graphique"
     * Orchestre toute l'analyse RIASEC et la visualisation des résultats
     */
    document.getElementById('plotBtn').addEventListener('click', ()=> {
      // Étape 1: Sélectionne les échelles cochées par l'utilisateur
      const selected = scales.filter(s=>s.selected);
      if (selected.length === 0) {
        alert('Sélectionne au moins une échelle à afficher.');
        return;
      }

      // Étape 2: Validation des données saisies
      for (let s of selected) {
        if (!validateScale(s)) {
          // Met en surbrillance les champs invalides
          LABELS.forEach((L,i)=> {
            const input = document.getElementById(`val-${s.id}-${L}`);
            const v = parseFloat(s.values[i]);
            if (s.values[i] === '' || isNaN(v) || v < 0 || v > s.max) {
              input.classList.add('invalid');
            }
          });
          alert(`Échelle "${s.name}" contient des valeurs invalides. Corrige les champs en rouge.`);
          return;
        }
      }

      // Étape 3: Préparation des données pour l'analyse
      const datasets = [], labelsForDatasets = [], summaries = [];

      selected.forEach((s, idx) => {
        // Normalise les scores pour le graphique (échelle 0-5)
        const norm = s.values.map(v => normalizeForChart(parseFloat(v), s.max));
        datasets.push(norm);
        labelsForDatasets.push(`${s.name} (max ${s.max})`);

        // Analyse complète du profil RIASEC
        const top = getTopTwoTypes(norm);                    // Types dominants
        const cons = evaluateConsistance(top[0], top[1]);    // Cohérence entre types
        const D = computeDifferentiationIndex_on100(s.values, s.max);  // Différentiation
        const cls = classifyDifferentiation(D);             // Classification H/F
        const pred = computePredigerOn100(s.values, s.max); // Dimensions de Prediger

        // Stockage des résultats pour le résumé
        summaries.push({ name: s.name, top, consistance: cons, D, class: cls, pred });
      });
      
      // Étape 4: Analyse de concordance globale (Kendall W)
    if (selected.length >= 2) {
      const ranksMatrix = selected.map(s => scoresToRanks(s.values.map(v => parseFloat(v))));
      const kendall = computeKendallW(ranksMatrix);
      const concordanceText = `\n\n🔁 Concordance globale (Kendall W) sur ${selected.length} échelles:\n` +
        `W = ${kendall.W} • χ² = ${kendall.chi2} (ddl=${kendall.ddl}) • p ${kendall.p}\n` +
        `→ ${kendall.interpretation}`;
  }
      // Étape 5: Visualisation et rapport
      renderChart(datasets, labelsForDatasets);           // Crée le graphique
      
      document.getElementById('summary').innerText = buildSummary(summaries) + concordanceText;  // Affiche le résumé
    });

    

    // =================================================================================
    // FONCTIONS UTILITAIRES ET GESTION DE L'ÉTAT
    // =================================================================================
    /**
 * Calcule l'indice de concordance de Kendall W entre plusieurs échelles
 * @param {number[][]} ranksMatrix - Matrice des rangs [échelle][type RIASEC]
 * @returns {object} Objet avec W, chi2, ddl, p-value approximative et interprétation
 */
    function computeKendallW(ranksMatrix) {
      const m = ranksMatrix.length;
      const n = ranksMatrix[0].length;
    
      const sumRanks = Array(n).fill(0);
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          sumRanks[j] += ranksMatrix[i][j];
        }
      }
    
      const mean = sumRanks.reduce((a, b) => a + b, 0) / n;
      const S = sumRanks.reduce((acc, r) => acc + Math.pow(r - mean, 2), 0);
      const W = (12 * S) / (m * m * (Math.pow(n, 3) - n));
      const chi2 = m * (n - 1) * W;
      const ddl = n - 1;
    
      let p;
      if (chi2 > 16.8) p = "< 0.001";
      else if (chi2 > 13.3) p = "< 0.01";
      else if (chi2 > 11.1) p = "< 0.025";
      else if (chi2 > 9.5) p = "< 0.05";
      else p = "≥ 0.05";
    
      let interpretation = "Faible concordance";
      if (W >= 0.8) interpretation = "Très forte concordance";
      else if (W >= 0.6) interpretation = "Bonne concordance";
      else if (W >= 0.4) interpretation = "Concordance modérée";
    
      return { W: Math.round(W * 1000) / 1000, chi2: Math.round(chi2 * 100) / 100, ddl, p, interpretation };
    }
    /**
     * Convertit un tableau de scores en rangs (ordre croissant)
     * @param {number[]} scores - Tableau de scores RIASEC
     * @returns {number[]} Tableau de rangs (1 = plus bas)
     */
    function scoresToRanks(scores) {
      const sorted = scores.map((v, i) => ({ v, i }))
        .sort((a, b) => a.v - b.v);
      const ranks = Array(scores.length);
      sorted.forEach((item, idx) => {
        ranks[item.i] = idx + 1;
      });
      return ranks;
    }

    
    /**
     * Nettoie l'affichage quand aucune échelle n'est sélectionnée
     * Supprime le graphique et efface le résumé pour éviter la confusion
     */
    function updateEmptyIfNeeded() {
      const anySelected = scales.some(s=>s.selected);
      if (!anySelected) {
        // Détruit le graphique s'il existe
        if (window.myChart) {
          window.myChart.destroy();
          window.myChart = null;
        }
        // Efface le résumé
        document.getElementById('summary').innerText = '';
      }
    }

    /**
     * Échappe les caractères HTML pour éviter les injections XSS
     * @param {string} str - Chaîne à échapper
     * @returns {string} Chaîne avec caractères HTML échappés
     */
    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, (m)=> ({
        '&':'&',
        '<':'<',
        '>':'>',
        '"':'"',
        "'":'&#39;'
      })[m]);
    }

    // =================================================================================
    // REDÉCLARATIONS POUR COMPATIBILITÉ (HOISTING)
    // =================================================================================
    /**
     * Redéclaration de validateScale pour s'assurer qu'elle existe
     * lors de la création des event listeners (histoire de hoisting)
     * @param {object} s - Objet échelle à valider
     * @returns {boolean} true si tous les scores sont valides
     */
    function validateScale(s) {
      for (let i=0;i<6;i++) {
        const raw = s.values[i];
        const v = parseFloat(raw);
        if (raw === '' || isNaN(v) || v < 0 || v > s.max) return false;
      }
      return true;
    }
  </script>
</body>
</html>
```
