<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Comparateur RIASEC ‚Äî Prediger (Objets/Personnes & Faits/Id√©es)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 18px; color:#222; }
    header { display:flex; align-items:center; gap:12px; margin-bottom:12px; flex-wrap:wrap; }
    h1 { font-size:1.2rem; margin:0; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .scales { display:flex; flex-direction:column; gap:12px; margin-top:12px; }
    .scale {
      border:1px solid #ddd; padding:10px; border-radius:8px; background:#fafafa;
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .scale h4 { margin:0 8px 0 0; font-size:0.95rem; }
    label { font-size:0.9rem; }
    input[type="text"], input[type="number"] {
      padding:6px 8px; border:1px solid #ccc; border-radius:6px; font-size:0.9rem;
    }
    .scores { display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .scores input { width:70px; }
    .invalid { border-color:#d93025; background:#ffecec; }
    .btn { padding:8px 12px; border-radius:6px; border:none; cursor:pointer; font-weight:600; }
    .btn-primary { background:#2b6cb0; color:white; }
    .btn-ghost { background:#fff; border:1px solid #ccc; color:#222; }
    .btn-danger { background:#d9534f; color:white; }
    #chart-wrap { max-width:920px; margin:18px auto; }
    #riasecChart { width:100% !important; height:520px !important; display:block; }
    #summary { text-align:left; margin-top:12px; font-weight:600; white-space:pre-wrap; }
    .small { font-weight:400; font-size:0.9rem; color:#444; margin-top:6px; }
    .note { font-size:0.9rem; color:#333; margin-top:8px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .prediger { font-size:0.9rem; color:#333; margin-top:8px;}
    @media (max-width:520px) {
      .scores input { width:56px; }
      input[type="text"], input[type="number"] { width:100%; }
      .scale { flex-direction:column; align-items:stretch; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Comparateur RIASEC ‚Äî multi-√©chelles + Prediger</h1>
    <div class="controls">
      <button id="addScaleBtn" class="btn btn-primary">+ Ajouter une √©chelle</button>
      <button id="plotBtn" class="btn btn-primary">Afficher le graphique</button>
      <button id="resetBtn" class="btn btn-ghost">R√©initialiser</button>
    </div>
  </header>

  <main>
    <div class="small">Ajoute des √©chelles, renseigne nom, √©tendue et scores R,I,A,S,E,C. Coche un ou plusieurs √©l√©ments pour les afficher. Pour la lisibilit√©, √©viter d'afficher trop de courbes simultan√©ment.</div>

    <div id="scalesContainer" class="scales"></div>

    <div id="chart-wrap">
      <canvas id="riasecChart"></canvas>
      <div id="summary" aria-live="polite"></div>

      <ul class="note" id="footnote">
        <strong>La diff√©rentiation </strong>est calcul√©e via la technique du Pr Vignaud et avec les √©talonnages du RIASEC Flash 2 du Fabien Beltrame <a href="http://deporientation.free.fr/Ressources/Manuel_RIASECFlash2_V3.1.pdf" target="_blank">r√©f√©rence page 17</a>
      </ul>

      <div class="note" id="diff-interpretation">
        <strong>Interpr√©tation de la diff√©renciation</strong> : un indice de diff√©renciation √©talonn√© en classe IV indique un profil RIASEC moyennement diff√©renci√© ; en classe I, II ou III le profil est faiblement diff√©renci√© ; en classe V, VI ou VII le profil est fortement diff√©renci√©.
      </div>

      <div class="prediger" id="prediger-note">
        Les <strong>dimensions de Prediger</strong> (calcul√©es avec la m√©thode de <a href="https://www.researchgate.net/publication/232418263_Adherence_to_RIASEC_Structure_as_a_Key_Career_Decision_Construct" target="_blank">Tracey</a>) sont : <em>Objets vs Personnes</em> et <em>Faits vs Id√©es</em>.
      </div>
    </div>
  </main>

  <script>
    // =================================================================================
    // CONSTANTES ET VARIABLES GLOBALES
    // =================================================================================
    // Labels RIASEC dans l'ordre standard
    const LABELS = ['R','I','A','S','E','C'];
    // Compteur pour g√©n√©rer des IDs uniques pour chaque √©chelle
    let scaleIdCounter = 0;
    // Stockage de toutes les √©chelles cr√©√©es
    // Structure: {id, name, max, values:[6], selected}
    let scales = [];

    // =================================================================================
    // PALETTE DE COULEURS POUR LES GRAPHES
    // =================================================================================
    // Palette de 8 couleurs distinctes pour diff√©rencier les √©chelles sur le graphique
    const BASE_COLORS = [
      'rgba(220,53,69,1)',    // Rouge
      'rgba(13,110,253,1)',   // Bleu
      'rgba(40,167,69,1)',    // Vert
      'rgba(255,193,7,1)',    // Jaune
      'rgba(102,16,242,1)',   // Violet
      'rgba(23,162,184,1)',   // Cyan
      'rgba(255,87,34,1)',    // Orange
      'rgba(0,123,255,1)'     // Bleu secondaire
    ];

    // =================================================================================
    // GESTION DES COULEURS POUR LES GRAPHES
    // =================================================================================
    /**
     * G√©n√®re une paire de couleurs (bordure + fond) pour une √©chelle donn√©e
     * @param {number} i - Index de l'√©chelle (0, 1, 2, etc.)
     * @returns {object} Objet avec border (opaque) et background (translucide)
     */
    function colorForIndex(i) {
      // S√©lectionne une couleur de base en bouclant sur la palette
      const base = BASE_COLORS[i % BASE_COLORS.length];
      // Cr√©e une version translucide pour le fond (remplace opacity 1 par 0.18)
      const bg = base.replace(/1\)$/, '0.18)');
      return { border: base, background: bg };
    }

    // =================================================================================
    // INITIALISATION DE L'APPLICATION
    // =================================================================================
    /**
     * √âv√©nement d√©clench√© quand le DOM est compl√®tement charg√©
     * Cr√©e automatiquement deux √©chelles d'exemple au d√©marrage
     */
    window.addEventListener('DOMContentLoaded', () => {
      // Ajoute une √©chelle d'auto√©valuation (notation 1-5)
      addScale('Auto√©valuation', 5, [0,0,0,0,0,0]);
      // Ajoute une √©chelle de test en ligne (notation 0-100)
      addScale('Test en ligne', 100, [0,0,0,0,0,0]);
    });

    // =================================================================================
    // GESTION DES √âCHELLES RIASEC
    // =================================================================================
    /**
     * Cr√©e une nouvelle √©chelle RIASEC avec ses contr√¥les HTML associ√©s
     * @param {string} name - Nom de l'√©chelle (ex: "Auto√©valuation", "Test professionnel")
     * @param {number} max - Valeur maximale possible (ex: 5 pour une √©chelle 1-5, 100 pour un test)
     * @param {number[]} values - Scores RIASEC [R, I, A, S, E, C]
     */
    function addScale(name='√âchelle', max=5, values=[0,0,0,0,0,0]) {
      const id = ++scaleIdCounter;
      const s = { id, name, max, values: values.slice(), selected: false };
      scales.push(s);

      const container = document.getElementById('scalesContainer');
      const el = document.createElement('div');
      el.className = 'scale';
      el.id = `scale-${id}`;
      el.innerHTML = `
        <div style="display:flex;align-items:center;gap:8px;">
          <input type="checkbox" id="select-${id}" aria-label="S√©lection ${id}">
        </div>
        <div style="flex:1;min-width:220px;">
          <div class="row">
            <h4>√âchelle</h4>
            <input type="text" id="name-${id}" value="${escapeHtml(name)}" style="min-width:160px;">
            <label>√âtendue max</label>
            <input type="number" id="max-${id}" value="${max}" min="1" step="any" style="width:85px;">
            <button class="btn btn-danger" id="del-${id}" title="Supprimer">Suppr</button>
          </div>
          <div class="scores" id="scores-${id}">
            ${LABELS.map((L,i)=>`<label>${L}: <input type="number" id="val-${id}-${L}" value="${values[i]}" step="any"></label>`).join('')}
          </div>
        </div>
      `;
      container.appendChild(el);

      document.getElementById(`del-${id}`).addEventListener('click', ()=> removeScale(id));
      document.getElementById(`select-${id}`).addEventListener('change', (e)=> toggleSelect(id, e.target.checked));
      document.getElementById(`name-${id}`).addEventListener('input', (e)=> updateScaleMeta(id,'name', e.target.value));
      document.getElementById(`max-${id}`).addEventListener('input', (e)=> updateScaleMeta(id,'max', parseFloat(e.target.value)));
      LABELS.forEach(L => {
        document.getElementById(`val-${id}-${L}`).addEventListener('input', (e)=> updateScaleValue(id, L, e.target.value));
      });
    }

    function removeScale(id) {
      scales = scales.filter(s=>s.id!==id);
      const el = document.getElementById(`scale-${id}`); if (el) el.remove();
      updateEmptyIfNeeded();
    }

    function updateScaleMeta(id, prop, val) {
      const s = scales.find(x=>x.id===id); if (!s) return;
      if (prop === 'max') s.max = (isNaN(val) || val <= 0) ? 1 : val;
      else s.name = String(val || '');
    }

    function updateScaleValue(id, label, raw) {
      const s = scales.find(x=>x.id===id); if (!s) return;
      const idx = LABELS.indexOf(label);
      const v = parseFloat(raw);
      s.values[idx] = raw === '' ? '' : (isNaN(v) ? '' : v);
      const input = document.getElementById(`val-${id}-${label}`);
      if (raw === '' || isNaN(v) || v < 0 || v > s.max) input.classList.add('invalid');
      else input.classList.remove('invalid');
    }

    function toggleSelect(id, checked) {
      const s = scales.find(x=>x.id===id); if (!s) return;
      s.selected = checked;
    }

    document.getElementById('addScaleBtn').addEventListener('click', ()=> {
      addScale('Nouvelle √©chelle', 5, [0,0,0,0,0,0]);
      const last = document.getElementById(`scale-${scaleIdCounter}`);
      if (last) last.scrollIntoView({ behavior:'smooth', block:'center' });
    });

    document.getElementById('resetBtn').addEventListener('click', ()=> {
      scales = []; scaleIdCounter = 0;
      document.getElementById('scalesContainer').innerHTML = '';
      document.getElementById('summary').innerText = '';
      if (window.myChart) { window.myChart.destroy(); window.myChart = null; }
      addScale('Auto√©valuation', 5, [0,0,0,0,0,0]);
      addScale('Test en ligne', 100, [0,0,0,0,0,0]);
    });

    function validateScale(s) {
      for (let i=0;i<6;i++) {
        const raw = s.values[i];
        const v = parseFloat(raw);
        if (raw === '' || isNaN(v) || v < 0 || v > s.max) return false;
      }
      return true;
    }

    // =================================================================================
    // FONCTIONS DE CALCUL ET DE NORMALISATION
    // =================================================================================
    /**
     * Normalise une valeur pour l'affichage sur le graphique radar (√©chelle 0-5)
     * @param {number} value - Valeur brute √† normaliser
     * @param {number} max - Valeur maximale possible pour cette √©chelle
     * @returns {number} Valeur normalis√©e entre 0 et 5
     */
    function normalizeForChart(value, max) {
      if (max <= 0) return 0;
      // Formule: (valeur / max) * 5, arrondi √† 1 d√©cimale
      return Math.round((value / max) * 5 * 10) / 10;
    }

    /**
     * Convertit une valeur en pourcentage (0-100%)
     * @param {number} value - Valeur √† convertir
     * @param {number} max - Valeur maximale de r√©f√©rence
     * @returns {number} Pourcentage arrondi
     */
    function toPercent100(value, max) {
      if (max <= 0) return 0;
      return (value / max) * 100;
    }

    /**
     * Identifie les deux types RIASEC dominants dans un profil
     * @param {number[]} scores - Scores RIASEC normalis√©s [R, I, A, S, E, C]
     * @returns {string[]} Les deux types principaux tri√©s par score d√©croissant
     */
    function getTopTwoTypes(scores) {
      // Associe chaque type √† son score
      const paired = LABELS.map((lab,i)=>({ type:lab, score:scores[i] }));
      // Trie par score d√©croissant
      paired.sort((a,b)=> b.score - a.score);
      return [paired[0].type, paired[1].type];
    }

    // =================================================================================
    // ANALYSE DE LA CONSISTANCE ENTRE TYPES RIASEC
    // =================================================================================
    /**
     * √âvalue la coh√©rence entre les deux types RIASEC dominants
     * Utilise la structure hexagonale RIASEC pour mesurer la proximit√©
     * @param {string} type1 - Premier type dominant (ex: "R", "I", "A", etc.)
     * @param {string} type2 - Deuxi√®me type dominant
     * @returns {string} Niveau de consistance: "Forte", "Moyenne" ou "Faible"
     */
    function evaluateConsistance(type1, type2) {
      // Structure hexagonale RIASEC dans l'ordre
      const hex = ['R','I','A','S','E','C'];
      // Trouve les positions des deux types dans l'hexagone
      const i1 = hex.indexOf(type1), i2 = hex.indexOf(type2);
      // Calcule la distance la plus courte (min entre sens horaire et anti-horaire)
      const d = Math.min(Math.abs(i1-i2), 6 - Math.abs(i1-i2));
      // Interpr√©tation selon la proximit√©:
      if (d === 1) return 'Forte';      // Types adjacents (R-I, I-A, etc.)
      if (d === 2) return 'Moyenne';    // Types espac√©s d'un intervalle
      return 'Faible';                  // Types oppos√©s ou tr√®s √©loign√©s
    }

    // =================================================================================
    // CALCUL DE L'INDICE DE DIFF√âRENTIATION RIASEC
    // =================================================================================
    /**
     * Calcule l'indice de diff√©rentiation selon la m√©thode de Pr Vignaud
     * Formule: D = (t1 - (t2 + t3)/2) + (t3 - (t4 + t5)/2)
     * o√π t1 √† t5 sont les 5 premiers scores tri√©s par ordre d√©croissant
     * @param {number[]} values - Scores RIASEC bruts [R, I, A, S, E, C]
     * @param {number} max - Valeur maximale possible pour cette √©chelle
     * @returns {number} Indice D arrondi √† 2 d√©cimales (√©chelle 0-24 max)
     */
    function computeDifferentiationIndex_on100(values, max) {
      // Convertit les scores selon l'√©talonnage RIASEC (max 24, pas 100)
      const normalized = values.map(v => (parseFloat(v) / max) * 24);
      // Trie les scores normalis√©s par ordre d√©croissant
      const s = normalized.slice().sort((a,b)=> b - a);
      // Extrait les 5 premiers scores (avec valeur par d√©faut 0 si undefined)
      const t1 = s[0] || 0, t2 = s[1] || 0, t3 = s[2] || 0, t4 = s[3] || 0, t5 = s[4] || 0;
      // Applique la formule de diff√©rentiation
      const D = (t1 - (t2 + t3)/2) + (t3 - (t4 + t5)/2);
      return Math.round(D * 100) / 100;
    }

    // =================================================================================
    // CLASSIFICATION DE LA DIFF√âRENTIATION PAR SEXE
    // =================================================================================
    /**
     * Classe l'indice de diff√©rentiation selon les normes √©tablies
     * Utilise des bar√®mes diff√©rents pour hommes et femmes selon RIASEC Flash 2
     * @param {number} D - Indice de diff√©rentiation calcul√© (√©chelle 0-24)
     * @returns {object} Objet avec les classes pour homme et femme
     */
    function classifyDifferentiation(D) {
      // D√©finition des classes avec intervalles sp√©cifiques homme/femme (RIASEC Flash 2)
      const classes = [
        { name:'I', homme:[0,2], femme:[0,2] },
        { name:'II', homme:[3,4], femme:[3,4] },
        { name:'III', homme:[5,6], femme:[5,8] },
        { name:'IV', homme:[7,8], femme:[9,10] },
        { name:'V', homme:[9,12], femme:[11,13] },
        { name:'VI', homme:[13,15], femme:[14,16] },
        { name:'VII', homme:[16,24], femme:[17,24] }
      ];

      /**
       * Trouve la classe correspondant √† un indice D pour un sexe donn√©
       * @param {number} D - Indice de diff√©rentiation
       * @param {string} sex - 'homme' ou 'femme'
       * @returns {string} Nom de la classe (I √† VII)
       */
      const findClass = (D, sex) => {
        for (let c of classes) {
          const r = sex === 'homme' ? c.homme : c.femme;
          if (D >= r[0] && D <= r[1]) return c.name;
        }
        return 'VII'; // Classe maximale par d√©faut
      };
      return { homme: findClass(D,'homme'), femme: findClass(D,'femme') };
    }

    /**
     * Convertit une classe de diff√©rentiation en niveau interpr√©table
     * @param {string} clsName - Nom de la classe (I, II, III, etc.)
     * @returns {string} Niveau de diff√©rentiation: "Faible", "Moyenne" ou "Forte"
     */
    function differentiationLevelFromClass(clsName) {
      if (['I','II','III'].includes(clsName)) return 'Faible';
      if (clsName === 'IV') return 'Moyenne';
      return 'Forte';
    }

    // =================================================================================
    // CALCUL DES DIMENSIONS DE PREDIGER/TRACEY
    // =================================================================================
    /**
     * Calcule les dimensions de Prediger selon la m√©thode de Tracey
     * Ces dimensions orthogonales aux types RIASEC permettent une analyse compl√©mentaire
     * @param {number[]} values - Scores RIASEC bruts [R, I, A, S, E, C]
     * @param {number} max - Valeur maximale possible pour cette √©chelle
     * @returns {object} Objet avec things_people et ideas_data
     *
     * Formules:
     * - Things/People = (2*R + I - A - 2*S - E + C)
     * - Ideas/Data = (1.73*I + 1.73*A - 1.73*E - 1.73*C)
     */
    function computePredigerOn100(values, max) {
      // Convertit les scores bruts en pourcentages
      const pct = values.map(v => toPercent100(parseFloat(v), max));

      // Mappe les valeurs selon l'ordre RIASEC standard
      const R = pct[0] || 0, I = pct[1] || 0, A = pct[2] || 0,
            S = pct[3] || 0, E = pct[4] || 0, C = pct[5] || 0;

      // Applique les formules de Prediger/Tracey
      const things_people = (2*R + I - A - 2*S - E + C);
      const ideas_data = (1.73*I + 1.73*A - 1.73*E - 1.73*C);

      // Retourne les valeurs arrondies √† 2 d√©cimales
      return {
        things_people: Math.round(things_people * 100) / 100,
        ideas_data: Math.round(ideas_data * 100) / 100
      };
    }

    // =================================================================================
    // VISUALISATION GRAPHIQUE AVEC CHART.JS
    // =================================================================================
    /**
     * Cr√©e et affiche le graphique radar RIASEC avec plusieurs √©chelles
     * @param {number[][]} datasets - Tableau de datasets (chaque dataset = [R,I,A,S,E,C] normalis√©s)
     * @param {string[]} labelsForDatasets - Noms des √©chelles pour la l√©gende
     */
    function renderChart(datasets, labelsForDatasets) {
      // Pr√©pare les donn√©es pour Chart.js
      const data = {
        // Labels des axes (types RIASEC)
        labels: LABELS,
        // Chaque √©chelle devient un dataset avec ses propres couleurs
        datasets: datasets.map((d,i) => {
          const col = colorForIndex(i);
          return {
            label: labelsForDatasets[i],
            data: d,
            borderColor: col.border,
            backgroundColor: col.background,
            pointBackgroundColor: col.border,
            fill: true
          };
        })
      };

      // Configuration du graphique radar
      const config = {
        type: 'radar',
        data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            r: {
              min:0,
              max:5,
              ticks:{ stepSize:1 },
              pointLabels: { font: { size:12 } }
            }
          },
          plugins: {
            title: { display:true, text:'Profil RIASEC (normalis√© 1‚Äì5)' },
            legend: { position:'top', labels: { usePointStyle:true } }
          }
        }
      };

      // R√©cup√®re le canvas et cr√©e/d√©truit le graphique
      const ctx = document.getElementById('riasecChart');
      if (window.myChart) window.myChart.destroy(); // √âvite les conflits
      window.myChart = new Chart(ctx, config);
    }

    // =================================================================================
    // G√âN√âRATION DU RAPPORT D'ANALYSE
    // =================================================================================
    /**
     * G√©n√®re un r√©sum√© d√©taill√© de l'analyse RIASEC pour chaque √©chelle
     * @param {object[]} entries - Tableau d'objets contenant les r√©sultats d'analyse
     * @returns {string} Rapport format√© avec tous les indicateurs
     */
    function buildSummary(entries) {
      return entries.map((e,i) => {
        // Convertit les classes en niveaux de diff√©rentiation lisibles
        const diffLevelH = differentiationLevelFromClass(e.class.homme);
        const diffLevelF = differentiationLevelFromClass(e.class.femme);

        // Interpr√®te les dimensions de Prediger
        const things_label = e.pred.things_people > 0 ? 'Orientation Objets' :
                           (e.pred.things_people < 0 ? 'Orientation Personnes' : 'Neutre');
        const ideas_label = e.pred.ideas_data > 0 ? 'Orientation Id√©es' :
                          (e.pred.ideas_data < 0 ? 'Orientation Faits' : 'Neutre');

        // Formatage du r√©sum√© pour une √©chelle
        return `${i+1}. ${e.name}:\n` +
               `  Profil: ${e.top[0]}${e.top[1]} ‚Üí Consistance ${e.consistance}\n` +
               `  Diff√©rentiation=${e.D} (sur base 24) ‚Ä¢ Classe H:${e.class.homme}/${diffLevelH} ‚Ä¢ Classe F:${e.class.femme}/${diffLevelF}\n` +
               `  Prediger: Objets/Personnes=${e.pred.things_people} (${things_label}); Faits/Id√©es=${e.pred.ideas_data} (${ideas_label})`;
      }).join('\n\n');
    }

    // =================================================================================
    // TRAITEMENT PRINCIPAL - ANALYSE ET VISUALISATION
    // =================================================================================
    /**
     * Gestionnaire d'√©v√©nement pour le bouton "Afficher le graphique"
     * Orchestre toute l'analyse RIASEC et la visualisation des r√©sultats
     */
    document.getElementById('plotBtn').addEventListener('click', ()=> {
      // √âtape 1: S√©lectionne les √©chelles coch√©es par l'utilisateur
      const selected = scales.filter(s=>s.selected);
      if (selected.length === 0) {
        alert('S√©lectionne au moins une √©chelle √† afficher.');
        return;
      }

      // √âtape 2: Validation des donn√©es saisies
      for (let s of selected) {
        if (!validateScale(s)) {
          // Met en surbrillance les champs invalides
          LABELS.forEach((L,i)=> {
            const input = document.getElementById(`val-${s.id}-${L}`);
            const v = parseFloat(s.values[i]);
            if (s.values[i] === '' || isNaN(v) || v < 0 || v > s.max) {
              input.classList.add('invalid');
            }
          });
          alert(`√âchelle "${s.name}" contient des valeurs invalides. Corrige les champs en rouge.`);
          return;
        }
      }

      // √âtape 3: Pr√©paration des donn√©es pour l'analyse
      const datasets = [], labelsForDatasets = [], summaries = [];

      selected.forEach((s, idx) => {
        // Normalise les scores pour le graphique (√©chelle 0-5)
        const norm = s.values.map(v => normalizeForChart(parseFloat(v), s.max));
        datasets.push(norm);
        labelsForDatasets.push(`${s.name} (max ${s.max})`);

        // Analyse compl√®te du profil RIASEC
        const top = getTopTwoTypes(norm);                    // Types dominants
        const cons = evaluateConsistance(top[0], top[1]);    // Coh√©rence entre types
        const D = computeDifferentiationIndex_on100(s.values, s.max);  // Diff√©rentiation
        const cls = classifyDifferentiation(D);             // Classification H/F
        const pred = computePredigerOn100(s.values, s.max); // Dimensions de Prediger

        // Stockage des r√©sultats pour le r√©sum√©
        summaries.push({ name: s.name, top, consistance: cons, D, class: cls, pred });
      });
      
      // √âtape 4: Analyse de concordance globale (Kendall W)
    if (selected.length >= 2) {
      const ranksMatrix = selected.map(s => scoresToRanks(s.values.map(v => parseFloat(v))));
      const kendall = computeKendallW(ranksMatrix);
      const concordanceText = `\n\nüîÅ Concordance globale (Kendall W) sur ${selected.length} √©chelles:\n` +
        `W = ${kendall.W} ‚Ä¢ œá¬≤ = ${kendall.chi2} (ddl=${kendall.ddl}) ‚Ä¢ p ${kendall.p}\n` +
        `‚Üí ${kendall.interpretation}`;
  }
      // √âtape 5: Visualisation et rapport
      renderChart(datasets, labelsForDatasets);           // Cr√©e le graphique
      
      document.getElementById('summary').innerText = buildSummary(summaries) + concordanceText;  // Affiche le r√©sum√©
    });

    

    // =================================================================================
    // FONCTIONS UTILITAIRES ET GESTION DE L'√âTAT
    // =================================================================================
    /**
 * Calcule l'indice de concordance de Kendall W entre plusieurs √©chelles
 * @param {number[][]} ranksMatrix - Matrice des rangs [√©chelle][type RIASEC]
 * @returns {object} Objet avec W, chi2, ddl, p-value approximative et interpr√©tation
 */
    function computeKendallW(ranksMatrix) {
      const m = ranksMatrix.length;
      const n = ranksMatrix[0].length;
    
      const sumRanks = Array(n).fill(0);
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          sumRanks[j] += ranksMatrix[i][j];
        }
      }
    
      const mean = sumRanks.reduce((a, b) => a + b, 0) / n;
      const S = sumRanks.reduce((acc, r) => acc + Math.pow(r - mean, 2), 0);
      const W = (12 * S) / (m * m * (Math.pow(n, 3) - n));
      const chi2 = m * (n - 1) * W;
      const ddl = n - 1;
    
      let p;
      if (chi2 > 16.8) p = "< 0.001";
      else if (chi2 > 13.3) p = "< 0.01";
      else if (chi2 > 11.1) p = "< 0.025";
      else if (chi2 > 9.5) p = "< 0.05";
      else p = "‚â• 0.05";
    
      let interpretation = "Faible concordance";
      if (W >= 0.8) interpretation = "Tr√®s forte concordance";
      else if (W >= 0.6) interpretation = "Bonne concordance";
      else if (W >= 0.4) interpretation = "Concordance mod√©r√©e";
    
      return { W: Math.round(W * 1000) / 1000, chi2: Math.round(chi2 * 100) / 100, ddl, p, interpretation };
    }
    /**
     * Convertit un tableau de scores en rangs (ordre croissant)
     * @param {number[]} scores - Tableau de scores RIASEC
     * @returns {number[]} Tableau de rangs (1 = plus bas)
     */
    function scoresToRanks(scores) {
      const sorted = scores.map((v, i) => ({ v, i }))
        .sort((a, b) => a.v - b.v);
      const ranks = Array(scores.length);
      sorted.forEach((item, idx) => {
        ranks[item.i] = idx + 1;
      });
      return ranks;
    }

    
    /**
     * Nettoie l'affichage quand aucune √©chelle n'est s√©lectionn√©e
     * Supprime le graphique et efface le r√©sum√© pour √©viter la confusion
     */
    function updateEmptyIfNeeded() {
      const anySelected = scales.some(s=>s.selected);
      if (!anySelected) {
        // D√©truit le graphique s'il existe
        if (window.myChart) {
          window.myChart.destroy();
          window.myChart = null;
        }
        // Efface le r√©sum√©
        document.getElementById('summary').innerText = '';
      }
    }

    /**
     * √âchappe les caract√®res HTML pour √©viter les injections XSS
     * @param {string} str - Cha√Æne √† √©chapper
     * @returns {string} Cha√Æne avec caract√®res HTML √©chapp√©s
     */
    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, (m)=> ({
        '&':'&',
        '<':'<',
        '>':'>',
        '"':'"',
        "'":'&#39;'
      })[m]);
    }

    // =================================================================================
    // RED√âCLARATIONS POUR COMPATIBILIT√â (HOISTING)
    // =================================================================================
    /**
     * Red√©claration de validateScale pour s'assurer qu'elle existe
     * lors de la cr√©ation des event listeners (histoire de hoisting)
     * @param {object} s - Objet √©chelle √† valider
     * @returns {boolean} true si tous les scores sont valides
     */
    function validateScale(s) {
      for (let i=0;i<6;i++) {
        const raw = s.values[i];
        const v = parseFloat(raw);
        if (raw === '' || isNaN(v) || v < 0 || v > s.max) return false;
      }
      return true;
    }
  </script>
</body>
</html>
```
